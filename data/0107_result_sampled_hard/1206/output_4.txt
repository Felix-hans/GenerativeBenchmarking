
Design a Skiplist without using any built-in libraries.

A skiplist is a data structure that takes O(log(n)) time to add, erase and
search. Comparing with treap and red-black tree which has the same function
and performance, the code length of Skiplist can be comparatively short and
the idea behind Skiplists is just simple linked lists.

For example, we have a Skiplist containing [30,40,50,60,70,90] and we want to
add 80 and 45 into it. The Skiplist works this way:


Artyom Kalinin [CC BY-SA 3.0], via Wikimedia Commons

You can see there are many layers in the Skiplist. Each layer is a sorted
linked list. With the help of the top layers, add, erase and search can be
faster than O(n). It can be proven that the average time complexity for each
operation is O(log(n)) and space complexity is O(n).

See more about Skiplist: https://en.wikipedia.org/wiki/Skip_list

Implement the Skiplist class:


Skiplist() Initializes the object of the skiplist.
bool search(int target) Returns true if the integer target exists in the
Skiplist or false otherwise.
void add(int num) Inserts the value num into the SkipList.
bool erase(int num) Removes the value num from the Skiplist and returns true.
If num does not exist in the Skiplist, do nothing and return false. If there
exist multiple num values, removing any one of them is fine.


Note that duplicates may exist in the Skiplist, your code needs to handle
this situation.


Example 1:


Input
["Skiplist", "add", "add", "add", "search", "add", "search", "erase",
"erase", "search"]
[[], [1], [2], [3], [0], [4], [1], [0], [1], [1]]
Output
[null, null, null, null, false, null, true, false, true, false]

Explanation
Skiplist skiplist = new Skiplist();
skiplist.add(1);
skiplist.add(2);
skiplist.add(3);
skiplist.search(0); // return False
skiplist.add(4);
skiplist.search(1); // return True
skiplist.erase(0);  // return False, 0 is not in skiplist.
skiplist.erase(1);  // return True
skiplist.search(1); // return False, 1 has already been erased.


Constraints:


0 <= num, target <= 2 * 10^4
At most 5 * 10^4 calls will be made to search, add, and erase.





```
class Skiplist:

    def __init__(self):
        

    def search(self, target: int) -> bool:
        

    def add(self, num: int) -> None:
        

    def erase(self, num: int) -> bool:
        


# Your Skiplist object will be instantiated and called as such:
# obj = Skiplist()
# param_1 = obj.search(target)
# obj.add(num)
# param_3 = obj.erase(num)
```Implement the above task in Python.        self.val = val
        self.right = None
        self.down = None

class Skiplist:
    def __init__(self):
        self.head = Node()  # Dummy node
        self.levels = [self.head]  # List of heads of each level

    def search(self, target: int) -> bool:
        curr = self.head
        while curr:
            if curr.right and curr.right.val < target:
                curr = curr.right
            elif curr.right and curr.right.val == target:
                return True
            else:
                curr = curr.down
        return False

    def add(self, num: int) -> None:
        nodes = []
        curr = self.head
        while curr:
            if curr.right and curr.right.val < num:
                curr = curr.right
            else:
                nodes.append(curr)
                curr = curr.down

        insert = True
        down = None
        while insert and nodes:
            node = nodes.pop()
            node.right = Node(num)
            node.right.down = down
            down = node.right
            insert = random.random() < 0.5

            if insert:
                new_head = Node()  # New level's head node
                new_head.down = self.head  # Connect to the level below
                new_head.right = down  # Connect to the new node
                self.head = new_head  # Update the top level's head
                nodes.append(new_head)  # Append the new head to the nodes list

    def erase(self, num: int) -> bool:
        curr = self.head
        found = False
        while curr:
            if curr.right and curr.right.val < num:
                curr = curr.right
            elif curr.right and curr.right.val == num:
                curr.right = curr.right.right
                found = True
                curr = curr.down
            else:
                curr = curr.down
        return found
```

You can test the implementation with the provided example:

```python
skiplist = Skiplist()
skiplist.add(1)
skiplist.add(2)
skiplist.add(3)
print(skiplist.search(0))  # False
skiplist.add(4)
print(skiplist.search(1))  # True
print(skiplist.erase(0))  # False
print(skiplist.erase(1))  # True
print(skiplist.search(1))  # False
```

The output will be:

```
False
True
False
True
False
```

The Skiplist class maintains a list of linked lists, with each linked list representing a level. The nodes are inserted randomly at higher levels to create the skip connections, which allows for faster searching. The `search` function traverses the skiplist by following the skip connections to find the target value. The `add` function inserts a new node into the skiplist at the appropriate level(s) by creating new nodes and adjusting the skip connections. The `erase` function removes a node from the skiplist by updating the skip connections.