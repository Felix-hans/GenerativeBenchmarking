To solve this problem, we can use dynamic programming to determine the optimal score for each player. We'll create a list, `dp`, where `dp[i]` represents the maximum score difference the current player can achieve starting from stone `i`. We'll iterate from right to left, calculating `dp[i]` for each stone.

In each iteration, we'll consider three possible moves: taking 1, 2, or 3 stones. We'll calculate the score for each move and choose the move that maximizes the score difference between the current player and the opponent. Finally, we'll check the value of `dp[0]` to determine the winner or if it's a tie.

Here's the implementation of the `stoneGameIII` function:

```python
from typing import List

class Solution:
    def stoneGameIII(self, stoneValue: List[int]) -> str:
        n = len(stoneValue)
        dp = [0] * (n + 1)

        for i in range(n - 1, -1, -1):
            best_score = float('-inf')

            for j in range(i, min(n, i + 3)):
                curr_score = sum(stoneValue[i:j + 1])
                best_score = max(best_score, curr_score - dp[j + 1])

            dp[i] = best_score

        if dp[0] > 0:
            return "Alice"
        elif dp[0] < 0:
            return "Bob"
        else:
            return "Tie"
```

Let's test the function with the provided examples:

```python
solution = Solution()

# Example 1
values = [1, 2, 3, 7]
print(solution.stoneGameIII(values))  # Output: "Bob"

# Example 2
values = [1, 2, 3, -9]
print(solution.stoneGameIII(values))  # Output: "Alice"

# Example 3
values = [1, 2, 3, 6]
print(solution.stoneGameIII(values))  # Output: "Tie"
```

The output matches the expected results.