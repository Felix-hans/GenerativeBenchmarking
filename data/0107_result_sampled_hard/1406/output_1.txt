To solve this problem, we can use dynamic programming. We'll create a table to store the optimal scores for each player at each step. The table will be initialized with zeros.

Let's define a function `stoneGameIII(stoneValue)` to implement this solution:

```python
def stoneGameIII(stoneValue):
    n = len(stoneValue)
    dp = [0] * (n + 1)  # Initialize the dp table

    for i in range(n - 1, -1, -1):
        best_score = float('-inf')  # Initialize the best score to negative infinity

        # Calculate the score for each possible move
        for j in range(i, min(n, i + 3)):
            score = sum(stoneValue[i:j + 1]) - dp[j + 1]  # Calculate the score

            best_score = max(best_score, score)  # Update the best score

        dp[i] = best_score  # Store the best score for the current position

    alice_score = dp[0]  # Alice's score
    bob_score = sum(stoneValue) - alice_score  # Bob's score

    if alice_score > bob_score:
        return "Alice"
    elif alice_score < bob_score:
        return "Bob"
    else:
        return "Tie"
```

Let's test the function with the provided examples:

```python
print(stoneGameIII([1, 2, 3, 7]))  # Output: "Bob"
print(stoneGameIII([1, 2, 3, -9]))  # Output: "Alice"
print(stoneGameIII([1, 2, 3, 6]))  # Output: "Tie"
```

The function should return the expected outputs for each example.