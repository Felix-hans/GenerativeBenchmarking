To find the kth smallest distance among all the pairs in the given array `nums`, we can use a binary search approach combined with a sliding window technique.

Here's the implementation of the `smallestDistancePair` function:

```python
from typing import List

class Solution:
    def smallestDistancePair(self, nums: List[int], k: int) -> int:
        nums.sort()  # Sort the array to simplify the search
        
        n = len(nums)
        left, right = 0, nums[-1] - nums[0]  # Initialize the search space
        
        while left < right:
            mid = (left + right) // 2
            count = 0  # Count of pairs with distance <= mid
            start = 0  # Start index of the sliding window
            
            # Count the number of pairs with distance <= mid
            for i in range(n):
                while nums[i] - nums[start] > mid:
                    start += 1
                count += i - start
            
            # Determine the next search space based on the count
            if count >= k:
                right = mid
            else:
                left = mid + 1
        
        return left
```

You can create an instance of the `Solution` class and call the `smallestDistancePair` method with the given inputs:

```python
nums = [1, 3, 1]
k = 1

solution = Solution()
result = solution.smallestDistancePair(nums, k)
print(result)
```

Output:
```
0
```

The implementation uses a binary search to narrow down the search space for the smallest distance. Inside the binary search loop, it counts the number of pairs with distance less than or equal to the current mid value. Based on this count, the search space is adjusted accordingly. Finally, the left value (which will be the kth smallest distance) is returned as the result.