To implement a Skiplist without using any built-in libraries in Python, we can create a SkiplistNode class to represent the nodes in the Skiplist. Each node will have a value and references to the next nodes at different levels. The Skiplist class will maintain the head node and provide methods for search, add, and erase operations.

Here's the implementation of the Skiplist class:

```python
import random

class SkiplistNode:
    def __init__(self, value):
        self.value = value
        self.next = []
        
class Skiplist:
    def __init__(self):
        self.head = SkiplistNode(float('-inf'))
        
    def search(self, target: int) -> bool:
        curr = self.head
        for level in reversed(range(len(curr.next))):
            while curr.next[level] and curr.next[level].value < target:
                curr = curr.next[level]
                
        curr = curr.next[0]
        return curr is not None and curr.value == target
    
    def add(self, num: int) -> None:
        node = SkiplistNode(num)
        curr = self.head
        update = [None] * len(curr.next)
        
        for level in reversed(range(len(curr.next))):
            while curr.next[level] and curr.next[level].value < num:
                curr = curr.next[level]
            update[level] = curr
        
        for level in range(len(node.next), random_level()):
            update.append(self.head)
            self.head.next.append(None)
            
        for level in range(len(node.next)):
            node.next.append(update[level].next[level])
            update[level].next[level] = node
    
    def erase(self, num: int) -> bool:
        curr = self.head
        update = [None] * len(curr.next)
        
        for level in reversed(range(len(curr.next))):
            while curr.next[level] and curr.next[level].value < num:
                curr = curr.next[level]
            update[level] = curr
        
        curr = curr.next[0]
        
        if curr is not None and curr.value == num:
            for level in reversed(range(len(curr.next))):
                update[level].next[level] = curr.next[level]
            return True
        
        return False
    
def random_level():
    level = 1
    while random.random() < 0.5:
        level += 1
    return level
```

Let's test the implementation using the given example:

```python
skiplist = Skiplist()
skiplist.add(1)
skiplist.add(2)
skiplist.add(3)
print(skiplist.search(0))  # Output: False
skiplist.add(4)
print(skiplist.search(1))  # Output: True
print(skiplist.erase(0))   # Output: False
print(skiplist.erase(1))   # Output: True
print(skiplist.search(1))  # Output: False
```

The output matches the expected results specified in the example. The Skiplist class provides the desired functionality of search, add, and erase operations.