To solve the problem, we can use dynamic programming. Let's define an array dp, where dp[i] represents the number of distinct subsequences ending at position i in the string s.

We can initialize dp with all zeros, except for dp[0], which will be 1 because there is always an empty subsequence.

For each character s[i] at position i in the string s, we can calculate the number of distinct subsequences ending at position i by considering two cases:

1. If we haven't seen the character s[i] before, then the number of distinct subsequences ending at position i is twice the number of distinct subsequences ending at position i-1 (dp[i] = 2 * dp[i-1]).

2. If we have seen the character s[i] before, then we need to subtract the number of distinct subsequences ending at the previous occurrence of s[i] (dp[i] = 2 * dp[i-1] - dp[last[s[i]]-1]), where last[s[i]] represents the index of the previous occurrence of s[i].

To handle the modulo operation, we can take the result modulo (10^9 + 7) at each step.

Here's the implementation of the Solution class:

```python
class Solution:
    def distinctSubseqII(self, s: str) -> int:
        n = len(s)
        dp = [0] * (n + 1)  # Initialize dp array
        
        last = {}  # To store the last occurrence of each character
        dp[0] = 1  # Empty subsequence
        
        for i in range(1, n + 1):
            dp[i] = (2 * dp[i - 1]) % (10**9 + 7)  # Case 1
            
            if s[i - 1] in last:
                dp[i] -= dp[last[s[i - 1]] - 1]  # Case 2
            last[s[i - 1]] = i
        
        return (dp[n] - 1) % (10**9 + 7)  # Subtract the empty subsequence
```

Let's test the solution with the given examples:

```python
solution = Solution()

# Example 1
s = "abc"
print(solution.distinctSubseqII(s))  # Output: 7

# Example 2
s = "aba"
print(solution.distinctSubseqII(s))  # Output: 6

# Example 3
s = "aaa"
print(solution.distinctSubseqII(s))  # Output: 3
```

The output of the test cases matches the expected results.