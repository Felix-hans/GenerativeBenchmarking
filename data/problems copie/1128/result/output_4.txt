To solve this task, we can iterate through the list of dominoes and count the frequency of each unique pair. Since a domino pair can be rotated, we need to consider both [a, b] and [b, a] as equivalent pairs.

Here's the implementation of the `numEquivDominoPairs` function in Python:

```python
from typing import List

class Solution:
    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:
        count = {}
        pairs = 0

        for domino in dominoes:
            # Sort the domino pair to handle rotations
            domino.sort()

            # Convert the sorted pair to a tuple for hashing
            domino_tuple = tuple(domino)

            # Increment the count of the current pair
            count[domino_tuple] = count.get(domino_tuple, 0) + 1

            # Count the number of equivalent pairs encountered so far
            pairs += count[domino_tuple] - 1

        return pairs
```

Example usage:

```python
solution = Solution()
dominoes = [[1,2],[2,1],[3,4],[5,6]]
print(solution.numEquivDominoPairs(dominoes))  # Output: 1

dominoes = [[1,2],[1,2],[1,1],[1,2],[2,2]]
print(solution.numEquivDominoPairs(dominoes))  # Output: 3
```

The `numEquivDominoPairs` function takes the list of dominoes as input and returns the number of equivalent pairs. We use a dictionary `count` to store the frequency of each unique pair encountered so far. By incrementing the count and adding the difference between the count and 1 to the `pairs` variable, we count the number of equivalent pairs. Finally, we return the `pairs` count as the result.