To solve this task, we can use a dictionary to count the number of occurrences of each equivalent domino. We iterate through the list of dominoes and convert each domino into a tuple `(min(a, b), max(a, b))`. This ensures that equivalent dominoes will have the same representation.

Here's the implementation of the `numEquivDominoPairs` function in Python:

```python
from typing import List

class Solution:
    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:
        count = {}
        pairs = 0

        for domino in dominoes:
            key = (min(domino), max(domino))
            if key in count:
                pairs += count[key]
                count[key] += 1
            else:
                count[key] = 1

        return pairs
```

You can create an instance of the `Solution` class and call the `numEquivDominoPairs` method with your list of dominoes to get the result. For example:

```python
solution = Solution()
dominoes = [[1, 2], [2, 1], [3, 4], [5, 6]]
result = solution.numEquivDominoPairs(dominoes)
print(result)  # Output: 1
```

Similarly, you can test the second example:

```python
solution = Solution()
dominoes = [[1, 2], [1, 2], [1, 1], [1, 2], [2, 2]]
result = solution.numEquivDominoPairs(dominoes)
print(result)  # Output: 3
```

The implementation has a time complexity of O(n), where n is the length of the `dominoes` list.