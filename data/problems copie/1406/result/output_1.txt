To solve this problem, we can use dynamic programming. We'll define a recursive function that calculates the maximum score each player can achieve starting from a given index in the `stoneValue` array. We'll keep track of the scores for Alice and Bob separately.

Here's the implementation of the `stoneGameIII` function:

```python
from typing import List

class Solution:
    def stoneGameIII(self, stoneValue: List[int]) -> str:
        n = len(stoneValue)
        dp = [float('-inf')] * (n + 1)
        dp[n] = 0  # Base case: No stones remaining, score is 0

        def calculateScore(index):
            if index >= n:
                return 0  # No more stones remaining, score is 0

            if dp[index] != float('-inf'):
                return dp[index]  # Return the precalculated score if available

            bestScore = float('-inf')
            currentSum = 0

            for i in range(index, min(index + 3, n)):
                currentSum += stoneValue[i]
                bestScore = max(bestScore, currentSum - calculateScore(i + 1))

            dp[index] = bestScore
            return bestScore

        aliceScore = calculateScore(0)
        bobScore = sum(stoneValue) - aliceScore

        if aliceScore > bobScore:
            return "Alice"
        elif aliceScore < bobScore:
            return "Bob"
        else:
            return "Tie"
```

Now, we can create an instance of the `Solution` class and call the `stoneGameIII` method with the `stoneValue` array as the input to get the result.

Example usage:

```python
solution = Solution()
print(solution.stoneGameIII([1, 2, 3, 7]))  # Output: "Bob"
print(solution.stoneGameIII([1, 2, 3, -9]))  # Output: "Alice"
print(solution.stoneGameIII([1, 2, 3, 6]))  # Output: "Tie"
```

The `stoneGameIII` function returns the winner of the game: "Alice", "Bob", or "Tie" based on their optimal moves.