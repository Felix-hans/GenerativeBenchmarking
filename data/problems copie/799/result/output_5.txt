To solve the problem, we can simulate the pouring process and track the amount of champagne in each glass. We'll initialize a 2D array to represent the pyramid of glasses and keep pouring champagne until we reach the desired row or until there is no more champagne left to pour.

Here's the implementation:

```python
class Solution:
    def champagneTower(self, poured: int, query_row: int, query_glass: int) -> float:
        # Initialize the pyramid of glasses with 0 champagne
        glasses = [[0] * i for i in range(1, query_row + 2)]
        glasses[0][0] = poured  # Pour the initial amount of champagne into the top glass
        
        for row in range(query_row + 1):
            for col in range(row + 1):
                # Check if the current glass has excess champagne
                excess = max(0, glasses[row][col] - 1)
                
                # Distribute the excess champagne to the glasses below
                if row + 1 < len(glasses):
                    glasses[row + 1][col] += excess / 2
                    glasses[row + 1][col + 1] += excess / 2
                
                # Update the current glass to its maximum capacity
                glasses[row][col] = min(1, glasses[row][col])
        
        return glasses[query_row][query_glass]
```

This solution keeps track of the champagne amount in each glass and distributes any excess champagne to the glasses in the next row. Finally, it returns the amount of champagne in the requested glass.

You can create an instance of the `Solution` class and call the `champagneTower` method with the provided input values to obtain the result. For example:

```python
solution = Solution()
print(solution.champagneTower(1, 1, 1))  # Output: 0.0
print(solution.champagneTower(2, 1, 1))  # Output: 0.5
print(solution.champagneTower(100000009, 33, 17))  # Output: 1.0
```

Please note that the solution assumes 0-indexing for the rows and glasses.