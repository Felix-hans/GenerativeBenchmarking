You can solve this problem by iterating from the square root of (num + 2) down to 1 and checking if the current number is a divisor of (num + 1) or (num + 2). Here's the implementation of the `closestDivisors` function:

```python
import math
from typing import List

class Solution:
    def closestDivisors(self, num: int) -> List[int]:
        divisors = []
        target_sums = [num + 1, num + 2]

        for target_sum in target_sums:
            for i in range(int(math.sqrt(target_sum)), 0, -1):
                if target_sum % i == 0:
                    j = target_sum // i
                    divisors.append([i, j])
                    break

        return divisors[-1]  # Return the closest divisors


# Example usage
solution = Solution()
print(solution.closestDivisors(8))   # Output: [3, 3]
print(solution.closestDivisors(123)) # Output: [5, 25]
print(solution.closestDivisors(999)) # Output: [40, 25]
```

This implementation finds the divisors for both `num + 1` and `num + 2`, and stores them in the `divisors` list. Then, it returns the last pair of divisors from the list, which will be the closest divisors.