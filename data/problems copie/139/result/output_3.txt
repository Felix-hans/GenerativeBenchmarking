To solve this problem, we can use dynamic programming. We'll create a boolean array `dp` of length `n+1`, where `n` is the length of the string `s`. Each element `dp[i]` will indicate whether the substring `s[0:i]` can be segmented into words from the `wordDict`.

Initially, we set `dp[0] = True` to indicate that an empty string can be segmented.

For each index `i` from 1 to `n`, we iterate through all the possible prefixes of the substring `s[0:i]`. If the prefix exists in the `wordDict` and the remaining substring after the prefix can also be segmented, then we set `dp[i] = True`.

Finally, we return `dp[n]` as the result, indicating whether the entire string `s` can be segmented.

Here's the implementation of the `wordBreak` function:

```python
from typing import List

class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        n = len(s)
        dp = [False] * (n + 1)
        dp[0] = True

        for i in range(1, n + 1):
            for j in range(i):
                if dp[j] and s[j:i] in wordDict:
                    dp[i] = True
                    break

        return dp[n]
```

You can create an instance of the `Solution` class and call the `wordBreak` function with the input string and word dictionary to test it:

```python
s = "leetcode"
wordDict = ["leet", "code"]
solution = Solution()
print(solution.wordBreak(s, wordDict))  # Output: True

s = "applepenapple"
wordDict = ["apple", "pen"]
solution = Solution()
print(solution.wordBreak(s, wordDict))  # Output: True

s = "catsandog"
wordDict = ["cats", "dog", "sand", "and", "cat"]
solution = Solution()
print(solution.wordBreak(s, wordDict))  # Output: False
```

The output will match the expected results mentioned in the examples.