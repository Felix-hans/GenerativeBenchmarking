To solve the given task, we can use a backtracking approach to generate all possible subsequences and check if each subsequence has unique characters. We'll keep track of the maximum length encountered during the process.

Here's the implementation of the `maxLength` function in Python:

```python
class Solution:
    def maxLength(self, arr: List[str]) -> int:
        def backtrack(index, path, unique_chars):
            nonlocal max_length

            # Base case: reached the end of arr or no more unique characters available
            if index == len(arr) or not unique_chars:
                max_length = max(max_length, len(path))
                return

            # Exclude the current string at index
            backtrack(index + 1, path, unique_chars)

            # Include the current string at index if it has unique characters
            if is_unique(arr[index], unique_chars):
                backtrack(index + 1, path + arr[index], unique_chars - set(arr[index]))

        def is_unique(s, unique_chars):
            return len(set(s)) == len(s) and set(s).isdisjoint(unique_chars)

        max_length = 0
        backtrack(0, "", set())

        return max_length
```

The `backtrack` function takes an index representing the current string being considered, `path` representing the concatenation of strings so far, and `unique_chars` representing the set of unique characters encountered so far. It explores two possibilities at each step: excluding the current string or including it if it has unique characters. The `is_unique` helper function checks whether a string has unique characters.

To find the maximum length, we start the backtracking process with an initial index of 0, an empty `path`, and an empty set of `unique_chars`. We update the `max_length` whenever a longer valid concatenation is found.

Finally, we return the `max_length` as the result.

Note: This implementation assumes that the input array `arr` contains only lowercase English letters as specified in the constraints.