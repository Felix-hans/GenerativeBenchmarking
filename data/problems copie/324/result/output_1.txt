To implement the given task in Python, you can follow the approach called "Wiggle Sort". Here's the implementation of the `wiggleSort` function using the provided skeleton code:

```python
from typing import List

class Solution:
    def wiggleSort(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        # Step 1: Sort the array in ascending order
        nums.sort()

        # Step 2: Find the mid index
        n = len(nums)
        mid = (n - 1) // 2

        # Step 3: Create two subarrays: one with elements after mid and the other with elements before mid
        subarray1 = nums[mid+1:]
        subarray2 = nums[:mid+1]

        # Step 4: Rearrange the elements in nums by taking elements from subarray1 and subarray2 alternately
        nums[::2] = subarray1[::-1]
        nums[1::2] = subarray2[::-1]
```

Explanation:
1. We first sort the array `nums` in ascending order.
2. Then we find the mid index `mid` of the sorted array. This will be the index where we start taking elements for the second subarray.
3. We create two subarrays: `subarray1` with elements after `mid` and `subarray2` with elements before or including `mid`.
4. We rearrange the elements in `nums` by taking elements alternately from `subarray1` and `subarray2`. We reverse both `subarray1` and `subarray2` to ensure that the wiggle condition is satisfied.

This implementation has a time complexity of O(nlogn) due to the initial sorting step. The space complexity is O(n) since we create two additional subarrays. However, the modification is done in-place using the `nums` array.