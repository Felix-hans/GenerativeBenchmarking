To solve the problem, we can use a list to store the ranges in sorted order. Each range will be represented as a tuple `(left, right)`. The list will maintain the ranges in sorted order based on the `left` value. When adding a new range, we'll insert it in the correct position to maintain the sorted order.

Here's the implementation of the `RangeModule` class in Python:

```python
class RangeModule:
    def __init__(self):
        self.ranges = []

    def addRange(self, left: int, right: int) -> None:
        # Find the correct position to insert the new range
        i = 0
        while i < len(self.ranges) and self.ranges[i][1] < left:
            i += 1

        # Merge overlapping or adjacent ranges
        while i < len(self.ranges) and self.ranges[i][0] <= right:
            left = min(left, self.ranges[i][0])
            right = max(right, self.ranges[i][1])
            self.ranges.pop(i)

        # Insert the merged range
        self.ranges.insert(i, (left, right))

    def queryRange(self, left: int, right: int) -> bool:
        # Find the first range that overlaps with the query range
        i = 0
        while i < len(self.ranges) and self.ranges[i][1] <= left:
            i += 1

        # Check if the overlapping range covers the query range
        if i < len(self.ranges) and self.ranges[i][0] <= left and self.ranges[i][1] >= right:
            return True

        return False

    def removeRange(self, left: int, right: int) -> None:
        # Find the first range that overlaps with the removal range
        i = 0
        while i < len(self.ranges) and self.ranges[i][1] < left:
            i += 1

        # Split or remove overlapping ranges
        while i < len(self.ranges) and self.ranges[i][0] < right:
            if self.ranges[i][0] < left:
                self.ranges.insert(i, (self.ranges[i][0], left))
                i += 1

            if self.ranges[i][1] > right:
                self.ranges.insert(i + 1, (right, self.ranges[i][1]))
                i += 2
            else:
                i += 1

        # Remove fully covered ranges
        j = 0
        while j < len(self.ranges) and self.ranges[j][1] <= left:
            j += 1
        self.ranges = self.ranges[:j]

```

Let's test the implementation with the given example:

```python
rangeModule = RangeModule()
rangeModule.addRange(10, 20)
rangeModule.removeRange(14, 16)
print(rangeModule.queryRange(10, 14))  # Output: True
print(rangeModule.queryRange(13, 15))  # Output: False
print(rangeModule.queryRange(16, 17))  # Output: True
```

The output matches the expected results `[True, False, True]`, indicating that the implementation is correct.