To move all zeros to the end of the array while maintaining the relative order of the non-zero elements, we can use a two-pointer approach. The idea is to keep one pointer, `i`, for iterating through the array, and another pointer, `j`, for keeping track of the position where the next non-zero element should be placed.

Here's the implementation of the `moveZeroes` function:

```python
class Solution:
    def moveZeroes(self, nums):
        """
        Do not return anything, modify nums in-place instead.
        """
        i = 0
        j = 0

        while i < len(nums):
            if nums[i] != 0:
                nums[j] = nums[i]
                j += 1
            i += 1

        while j < len(nums):
            nums[j] = 0
            j += 1
```

This solution uses two pointers, `i` and `j`. Pointer `i` iterates through the array, and when it encounters a non-zero element, it copies that element to the position pointed by `j` and increments `j`. After the first pass, all non-zero elements will be in their correct positions, and the remaining elements from `j` to the end of the array are filled with zeros in the second pass.

Here's how you can use the `moveZeroes` function:

```python
nums = [0, 1, 0, 3, 12]
solution = Solution()
solution.moveZeroes(nums)
print(nums)  # Output: [1, 3, 12, 0, 0]
```

The output will be `[1, 3, 12, 0, 0]`, which is the input array with all zeros moved to the end while maintaining the relative order of the non-zero elements.