You can solve this problem using dynamic programming. Here's an implementation of the `maximalSquare` function in Python:

```python
from typing import List

class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -> int:
        if not matrix or not matrix[0]:
            return 0
        
        m, n = len(matrix), len(matrix[0])
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        max_side = 0
        
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if matrix[i - 1][j - 1] == '1':
                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1
                    max_side = max(max_side, dp[i][j])
        
        return max_side * max_side
```

Explanation:

1. We first handle the base cases. If the matrix is empty or contains no elements, the maximum square area is 0, so we return it immediately.

2. We initialize an `dp` matrix of size `(m+1) x (n+1)` with all elements set to 0. This extra row and column will help handle the boundary cases.

3. We iterate through the matrix starting from index `(1, 1)` (1-based indexing). For each cell `(i, j)` in the original matrix, we check if it contains '1'.

4. If the current cell contains '1', we calculate the size of the largest square that can be formed using that cell as the bottom-right corner. The size is determined by taking the minimum value among the three adjacent cells above, to the left, and diagonally above to the left, and adding 1 to it. We update the `dp` matrix accordingly.

5. We keep track of the maximum side length of the square encountered so far (`max_side`).

6. Finally, we return the square of `max_side` as the maximum square area.

You can create an instance of the `Solution` class and call the `maximalSquare` method with your input matrix to obtain the result.