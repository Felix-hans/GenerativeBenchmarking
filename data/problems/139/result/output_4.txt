To solve the given task, we can use a dynamic programming approach. We'll create a boolean array `dp` of size `n+1`, where `n` is the length of string `s`. Each element `dp[i]` will indicate whether the substring from index 0 to `i-1` can be segmented into words from the dictionary.

We'll initialize `dp[0]` as `True` since an empty string can always be segmented. Then, for each index `i` from 1 to `n`, we'll check if there is a word in the dictionary that ends at index `i-1`. If we find such a word, and if `dp[j]` is `True` for some index `j` less than `i`, it means that the substring from index `j` to `i-1` can be segmented. In that case, we'll set `dp[i]` as `True`.

Finally, we'll return the value of `dp[n]` which indicates whether the entire string `s` can be segmented.

Here's the implementation of the `wordBreak` function:

```python
from typing import List

class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        n = len(s)
        dp = [False] * (n + 1)
        dp[0] = True

        for i in range(1, n + 1):
            for word in wordDict:
                if i >= len(word) and dp[i - len(word)] and s[i - len(word):i] == word:
                    dp[i] = True
                    break

        return dp[n]
```

Now we can create an instance of the `Solution` class and test the function with the given examples:

```python
solution = Solution()

s = "leetcode"
wordDict = ["leet", "code"]
print(solution.wordBreak(s, wordDict))  # Output: True

s = "applepenapple"
wordDict = ["apple", "pen"]
print(solution.wordBreak(s, wordDict))  # Output: True

s = "catsandog"
wordDict = ["cats", "dog", "sand", "and", "cat"]
print(solution.wordBreak(s, wordDict))  # Output: False
```

The function returns the expected results for the given examples.