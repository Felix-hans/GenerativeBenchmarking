To solve the problem, we can use dynamic programming. We'll create a list `dp` of size `n + k + 1`, where `dp[i]` represents the probability of having `i` or fewer points. Initially, all values in `dp` are set to 0 except for `dp[0]`, which is set to 1 since Alice starts with 0 points.

Next, we'll iterate through the elements of `dp` and calculate the cumulative probability. For each index `i`, we'll sum the probabilities of reaching `i` from the previous `maxPts` indices. To calculate the probability, we need to consider two cases:

1. If `i` is less than `k`, we can reach `i` from `i - 1` with a probability of `dp[i - 1] / maxPts`. Additionally, we can reach `i` from `i - 2` with a probability of `dp[i - 2] / maxPts`, and so on until `i - maxPts` with probabilities `dp[i - maxPts] / maxPts`. Therefore, the probability of reaching `i` is the sum of these probabilities.

2. If `i` is greater than or equal to `k`, we only need to consider the probabilities of reaching `i` from `i - 1` with a probability of `dp[i - 1] / maxPts`, `dp[i - 2] / maxPts`, and so on until `i - maxPts` with probabilities `dp[i - maxPts] / maxPts`. However, in this case, we also need to subtract the probability of reaching points greater than or equal to `k` because Alice stops drawing cards once she reaches `k` or more points. So the probability of reaching `i` is the sum of these probabilities minus the sum of probabilities from `k` to `i - 1`.

Finally, we'll return the sum of probabilities from `0` to `n`, which represents the probability of having `n` or fewer points.

Here's the implementation of the `new21Game` method:

```python
class Solution:
    def new21Game(self, n: int, k: int, maxPts: int) -> float:
        if k == 0 or n >= k + maxPts:
            return 1.0

        dp = [0.0] * (n + k + 1)
        dp[0] = 1.0
        cumulative_prob = 0.0

        for i in range(1, n + k + 1):
            if i <= k:
                cumulative_prob += dp[i - 1] / maxPts
            else:
                cumulative_prob += dp[i - 1] / maxPts - dp[i - k - 1] / maxPts

            dp[i] = cumulative_prob

            if i > n:
                dp[i] -= dp[i - (n + 1)]

        return dp[n]
```

Now we can test the solution with the provided examples:

```python
solution = Solution()

print(solution.new21Game(10, 1, 10))  # Output: 1.0
print(solution.new21Game(6, 1, 10))   # Output: 0.6
print(solution.new21Game(21, 17, 10)) # Output: 0.73278
```

The output matches the expected results for the provided examples.