To solve this problem, we can use dynamic programming to find the minimum cost to reach each step. We'll start from the bottom and work our way up to the top.

Here's the implementation of the `minCostClimbingStairs` function:

```python
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        n = len(cost)
        dp = [0] * (n + 1)  # dp[i] represents the minimum cost to reach step i
        
        for i in range(2, n + 1):
            dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])
        
        return dp[n]
```

In this solution, `dp` is an array of size `n + 1` where `dp[i]` represents the minimum cost to reach step `i`. We initialize `dp` with all zeros.

We iterate from step 2 to step `n` (the top of the stairs) and calculate the minimum cost to reach each step. The minimum cost to reach step `i` can be calculated as the minimum of two possibilities:
1. Pay the cost of the current step (`cost[i - 1]`) and add it to the minimum cost to reach the previous step (`dp[i - 1]`).
2. Pay the cost of the previous step (`cost[i - 2]`) and add it to the minimum cost to reach two steps below (`dp[i - 2]`).

Finally, we return `dp[n]`, which represents the minimum cost to reach the top of the stairs.

Let's test the solution with the given examples:

```python
solution = Solution()
cost = [10, 15, 20]
print(solution.minCostClimbingStairs(cost))  # Output: 15

cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
print(solution.minCostClimbingStairs(cost))  # Output: 6
```

The output matches the expected results.