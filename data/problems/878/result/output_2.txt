To solve this problem, we can use the concept of the least common multiple (LCM) of two numbers.

The LCM of two numbers, a and b, is the smallest positive integer that is divisible by both a and b. If we consider the sequence of magical numbers generated by a and b, we can observe that it follows a pattern based on the LCM.

Let's say the LCM of a and b is lcm. In every lcm numbers, there will be exactly lcm//a numbers divisible by a and lcm//b numbers divisible by b. Therefore, the total number of magical numbers in each lcm block is lcm//a + lcm//b - 1 (subtracting 1 to avoid double-counting the lcm itself).

Now, we can determine the number of lcm blocks needed to reach the nth magical number. We divide n by the total number of magical numbers in each block (lcm//a + lcm//b - 1). This gives us the quotient q and remainder r. The quotient represents the number of complete lcm blocks, and the remainder represents the position within the remaining block.

To find the nth magical number, we need to calculate lcm * q + rth magical number within a single lcm block.

Here's the implementation of the given task:

```python
class Solution:
    def nthMagicalNumber(self, n: int, a: int, b: int) -> int:
        def gcd(x, y):
            while y:
                x, y = y, x % y
            return x
        
        def lcm(x, y):
            return x * y // gcd(x, y)
        
        MOD = 10**9 + 7
        
        lcm_ab = lcm(a, b)
        magical_numbers_in_block = lcm_ab // a + lcm_ab // b - 1
        
        q, r = divmod(n, magical_numbers_in_block)
        result = lcm_ab * q % MOD
        
        if r == 0:
            return result
        
        heap = [(a * i, a, b) for i in range(1, a + 1)]
        heapq.heapify(heap)
        
        for _ in range(r - 1):
            num, a, b = heapq.heappop(heap)
            
            if num % b != 0:
                heapq.heappush(heap, (num + a, a, b))
        
        return (result + heap[0][0]) % MOD
```

Now, you can create an instance of the `Solution` class and call the `nthMagicalNumber` method to find the nth magical number. For example:

```python
solution = Solution()
n = 4
a = 2
b = 3
result = solution.nthMagicalNumber(n, a, b)
print(result)  # Output: 6
```

The code uses the heapq module to efficiently generate the magical numbers within a single lcm block. The final result is returned modulo 10^9 + 7 to handle large numbers.