You can solve the problem by using a dictionary to count the frequency of each number in the input array. Then, iterate through the dictionary and check if the current number plus one exists in the dictionary. If it does, calculate the length of the harmonious subsequence that includes both the current number and the current number plus one, and update the maximum length accordingly.

Here's the implementation of the `findLHS` function in Python:

```python
from typing import List

class Solution:
    def findLHS(self, nums: List[int]) -> int:
        num_freq = {}
        max_length = 0
        
        # Count the frequency of each number
        for num in nums:
            num_freq[num] = num_freq.get(num, 0) + 1
        
        # Check for harmonious subsequences
        for num in num_freq:
            if num + 1 in num_freq:
                subseq_length = num_freq[num] + num_freq[num + 1]
                max_length = max(max_length, subseq_length)
        
        return max_length
```

You can create an instance of the `Solution` class and call the `findLHS` function, passing the `nums` list as an argument. For example:

```python
nums = [1, 3, 2, 2, 5, 2, 3, 7]
solution = Solution()
result = solution.findLHS(nums)
print(result)
```

Output:
```
5
```

This means that the longest harmonious subsequence in the `nums` list is `[3, 2, 2, 2, 3]` with a length of 5.