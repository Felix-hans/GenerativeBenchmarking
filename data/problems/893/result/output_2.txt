To solve this task, we can use a set to keep track of the unique groups of special-equivalent strings. We will iterate through each word in the given list and generate its special-equivalent representation. We can then add this representation to the set. At the end, the size of the set will give us the number of unique groups.

Here's the implementation of the `numSpecialEquivGroups` function:

```python
from typing import List

class Solution:
    def numSpecialEquivGroups(self, words: List[str]) -> int:
        def get_special_equiv_representation(word):
            even_chars = sorted(word[0::2])
            odd_chars = sorted(word[1::2])
            return ''.join(even_chars) + ''.join(odd_chars)
        
        groups = set()
        for word in words:
            representation = get_special_equiv_representation(word)
            groups.add(representation)
        
        return len(groups)
```

We define a helper function `get_special_equiv_representation` which takes a word and returns its special-equivalent representation. It does so by sorting the even-indexed characters and odd-indexed characters separately and then concatenating them.

In the main `numSpecialEquivGroups` function, we initialize an empty set called `groups` to store the unique representations. We iterate through each word in the given list and obtain its special-equivalent representation using the helper function. We add this representation to the `groups` set.

Finally, we return the length of the `groups` set, which represents the number of unique groups of special-equivalent strings.

You can create an instance of the `Solution` class and call the `numSpecialEquivGroups` function with the input array to test it:

```python
solution = Solution()
words = ["abcd", "cdab", "cbad", "xyzz", "zzxy", "zzyx"]
print(solution.numSpecialEquivGroups(words))
```

This will output:
```
3
```

You can follow a similar approach for the second example as well.