Alice and Bob take turns playing a game, with Alice starting first.

Initially, there is a number n on the chalkboard. On each player's turn, that
player makes a move consisting of:


Choosing any x with 0 < x < n and n % x == 0.
Replacing the number n on the chalkboard with n - x.


Also, if a player cannot make a move, they lose the game.

Return true if and only if Alice wins the game, assuming both players play
optimally.


Example 1:


Input: n = 2
Output: true
Explanation: Alice chooses 1, and Bob has no more moves.


Example 2:


Input: n = 3
Output: false
Explanation: Alice chooses 1, Bob chooses 1, and Alice has no more moves.



Constraints:


1 <= n <= 1000





```
class Solution:
    def divisorGame(self, n: int) -> bool:
```Implement the above task in Python. will always win. On the other hand, if Alice starts with an odd number, she will always lose. 

We can prove this by considering the possible scenarios:

1. If Alice starts with an even number, she can choose x = 1 and reduce the number to an odd number. Now, Bob is left with an odd number. The only possible move for Bob is to choose x = 1 and reduce the number back to an even number. This process continues, with Alice always choosing x = 1 on her turn until the number becomes 2. At this point, Bob cannot make a move, and Alice wins.

2. If Alice starts with an odd number, the only possible move for Alice is to choose x = 1 and reduce the number to an even number. Now, Bob is left with an even number. Following the same logic as in scenario 1, Bob will always win because he can keep choosing x = 1 on his turn until the number becomes 2, leaving Alice with no move.

Based on this analysis, we can see that Alice wins if and only if the initial number is even.

Here's the implementation of the `divisorGame` function in Python:

```python
class Solution:
    def divisorGame(self, n: int) -> bool:
        return n % 2 == 0
```

This solution has a time complexity of O(1) since checking if a number is even can be done in constant time.