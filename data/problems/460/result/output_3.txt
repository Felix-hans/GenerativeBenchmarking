To implement a Least Frequently Used (LFU) cache, we can use a combination of data structures to efficiently track the frequency and recency of key accesses. Here's the implementation in Python:

```python
class LFUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.key_to_value = {}  # Stores key-value pairs
        self.key_to_freq = {}  # Stores key-frequency pairs
        self.freq_to_keys = {}  # Stores frequency-key pairs
        self.min_freq = 0  # Tracks the minimum frequency

    def get(self, key: int) -> int:
        if key not in self.key_to_value:
            return -1

        # Update the frequency of the accessed key
        freq = self.key_to_freq[key]
        self.key_to_freq[key] = freq + 1

        # Remove the key from the current frequency list
        self.freq_to_keys[freq].remove(key)

        # If the current frequency list is empty and equal to the min_freq, increment min_freq
        if len(self.freq_to_keys[freq]) == 0 and freq == self.min_freq:
            self.min_freq += 1

        # Add the key to the new frequency list
        if freq + 1 not in self.freq_to_keys:
            self.freq_to_keys[freq + 1] = []
        self.freq_to_keys[freq + 1].append(key)

        return self.key_to_value[key]

    def put(self, key: int, value: int) -> None:
        if self.capacity == 0:
            return

        # If the key already exists, update its value and call get() to increment its frequency
        if key in self.key_to_value:
            self.key_to_value[key] = value
            self.get(key)
            return

        # If the cache is full, invalidate the least frequently used key
        if len(self.key_to_value) >= self.capacity:
            # Get the least frequently used key from the minimum frequency list
            evicted_key = self.freq_to_keys[self.min_freq][0]

            # Remove the evicted key from all data structures
            del self.key_to_value[evicted_key]
            del self.key_to_freq[evicted_key]
            self.freq_to_keys[self.min_freq].pop(0)

        # Add the new key to all data structures with initial frequency 1
        self.key_to_value[key] = value
        self.key_to_freq[key] = 1
        self.freq_to_keys[1] = self.freq_to_keys.get(1, [])
        self.freq_to_keys[1].append(key)

        # Reset the min_freq to 1 since a new key is inserted
        self.min_freq = 1
```

Here's how you can test the implementation using the given example:

```python
cache = LFUCache(2)
cache.put(1, 1)  # cache=[1,_], cnt(1)=1
cache.put(2, 2)  # cache=[2,1], cnt(2)=1, cnt(1)=1
print(cache.get(1))  # Output: 1
cache.put(3, 3)  # 2 is the LFU key because cnt(2)=1 is the smallest, invalidate 2.
# cache=[3,1], cnt(3)=1, cnt(1)=2
print(cache.get(2))  # Output: -1 (not found)
print(cache.get(3))  # Output: 3
# cache=[3,1], cnt(3)=2, cnt(1)=2
cache.put(4, 