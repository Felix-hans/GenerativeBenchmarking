To solve this task, we can use the concept of Pascal's triangle. Each row in Pascal's triangle can be generated by adding the corresponding elements from the previous row. We start with the first row, which is always [1], and then iterate to generate the desired row.

Here's the Python code that implements the solution:

```python
from typing import List

class Solution:
    def getRow(self, rowIndex: int) -> List[int]:
        # Initialize the first row as [1]
        row = [1]

        # Iterate rowIndex times to generate the desired row
        for i in range(rowIndex):
            # Generate the next row by adding corresponding elements from the previous row
            next_row = [1]  # The first element is always 1

            for j in range(1, len(row)):
                next_row.append(row[j-1] + row[j])

            next_row.append(1)  # The last element is always 1
            row = next_row

        return row
```

We create a class `Solution` with a method `getRow` that takes an integer `rowIndex` and returns the `rowIndex`-th row of Pascal's triangle as a list.

To generate the desired row, we iterate `rowIndex` times. In each iteration, we generate the next row by adding the corresponding elements from the previous row. We initialize the `next_row` with the first element as 1, then iterate over the elements of the `row` list (previous row) and add the sum of each pair of adjacent elements. Finally, we append 1 to the `next_row` list as the last element. After each iteration, we update `row` to be the `next_row`.

Finally, we return the `row` list, which represents the `rowIndex`-th row of Pascal's triangle.

This solution has a time complexity of O(rowIndex^2) since we generate each row by iterating over the previous row. However, it satisfies the constraint of using O(rowIndex) extra space since we only store the current row and the next row at any given time.