Sure! Here's the implementation of the LRUCache class in Python:

```python
class LRUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = {}
        self.key_order = []  # Maintain the order of keys based on their recent usage

    def get(self, key: int) -> int:
        if key in self.cache:
            self.key_order.remove(key)  # Remove the key from its current position
            self.key_order.append(key)  # Add the key to the end of the order list
            return self.cache[key]
        else:
            return -1

    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self.key_order.remove(key)  # Remove the key from its current position
        elif len(self.cache) >= self.capacity:
            lru_key = self.key_order.pop(0)  # Remove the least recently used key
            del self.cache[lru_key]

        self.cache[key] = value
        self.key_order.append(key)  # Add the key to the end of the order list
```

You can test the LRUCache class using the example you provided:

```python
lRUCache = LRUCache(2)
lRUCache.put(1, 1)
lRUCache.put(2, 2)
print(lRUCache.get(1))  # Output: 1
lRUCache.put(3, 3)
print(lRUCache.get(2))  # Output: -1
lRUCache.put(4, 4)
print(lRUCache.get(1))  # Output: -1
print(lRUCache.get(3))  # Output: 3
print(lRUCache.get(4))  # Output: 4
```

The LRUCache class maintains a dictionary (`self.cache`) to store key-value pairs and a list (`self.key_order`) to maintain the order of keys based on their recent usage. When a key is accessed or added, it is moved to the end of the order list. If the cache exceeds its capacity, the least recently used key is evicted by removing it from the dictionary and the order list. The `get` method returns the value of the key if it exists, otherwise -1 is returned. The `put` method updates the value of the key if it exists or adds the key-value pair to the cache.