Here is the code implementation for the given task:

```go
import (
    "fmt"
    "math"
)

func isGuarded(row, col int, guards [][]int, walls [][]int) bool {
    // Check if the cell is a guard position
    for _, guard := range guards {
        if guard[0] == row && guard[1] == col {
            return true
        }
    }

    // Check if the cell is blocked by a wall
    for _, wall := range walls {
        wallRow, wallCol := wall[0], wall[1]
        if wallRow == row && wallCol == col {
            return true
        }
    }

    return false
}

func countUnguarded(m int, n int, guards [][]int, walls [][]int) int {
    unguarded := 0

    // Iterate over all cells in the grid
    for row := 0; row < m; row++ {
        for col := 0; col < n; col++ {
            isUnguarded := true

            // Check if the current cell is guarded
            if isGuarded(row, col, guards, walls) {
                isUnguarded = false
            } else {
                // Check if any adjacent cell is a guard
                // North
                if row > 0 && isGuarded(row-1, col, guards, walls) {
                    isUnguarded = false
                }
                // East
                if col < n-1 && isGuarded(row, col+1, guards, walls) {
                    isUnguarded = false
                }
                // South
                if row < m-1 && isGuarded(row+1, col, guards, walls) {
                    isUnguarded = false
                }
                // West
                if col > 0 && isGuarded(row, col-1, guards, walls) {
                    isUnguarded = false
                }
            }

            // Count the unguarded cells
            if isUnguarded {
                unguarded++
            }
        }
    }

    return unguarded
}
```

Example usage:
```go
func main() {
    m, n := 4, 6
    guards := [][]int{{0, 0}, {1, 1}, {2, 3}}
    walls := [][]int{{0, 1}, {2, 2}, {1, 4}}
    result := countUnguarded(m, n, guards, walls)
    fmt.Println(result) // Output: 7
}
```