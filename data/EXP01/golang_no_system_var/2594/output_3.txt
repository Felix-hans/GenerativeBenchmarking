To solve this problem, we can sort the array ranks in descending order. This way, the mechanic with the highest rank will repair the most cars in the shortest amount of time.

We can then iterate through the sorted ranks and calculate the total time needed to repair all the cars. For each mechanic, we calculate the number of cars they can repair (r * n^2) and subtract it from the total number of cars. The remaining cars are then passed to the next mechanic with a lower rank.

Here is the implementation in Go:

```go
import "sort"

func repairCars(ranks []int, cars int) int64 {
    sort.Sort(sort.Reverse(sort.IntSlice(ranks))) // Sort ranks in descending order
    var time int64

    for i, rank := range ranks {
        repairableCars := rank * (i+1) * (i+1) // Calculate number of cars this mechanic can repair

        if repairableCars >= cars {
            time += int64(cars) * int64((i+1) * (i+1))
            break // All cars have been repaired
        } else {
            time += int64(repairableCars) * int64((i+1) * (i+1))
            cars -= repairableCars // Update the number of remaining cars
        }
    }

    return time
}
```

The main idea is to iterate through the mechanics in descending order of rank and calculate the number of cars each mechanic can repair. If the number of repairable cars is greater than or equal to the total number of cars, we calculate the time needed to repair the remaining cars and exit the loop. Otherwise, we add the time needed to repair all the cars for this mechanic and subtract the number of repairable cars from the total. Finally, we return the total time needed to repair all the cars.

The time complexity of this solution is O(nlogn), where n is the length of the ranks array, due to the sorting step. The space complexity is O(n) as we need to sort the ranks array.