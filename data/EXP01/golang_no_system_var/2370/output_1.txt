To solve this task, we can use a dynamic programming approach.

First, we need to create a 2D array dp with dimensions (26, k+1), where dp[i][j] represents the maximum length of an ideal subsequence that starts with the letter i+'a' and has a difference of j with the previous letter.

Next, we can iterate over the string s from left to right. For each letter in s, we update the corresponding dp[i][j] values based on the previous dp array and the current letter.

Finally, the maximum value in the dp array will represent the length of the longest ideal subsequence.

Here is the implementation of the solution in Go:

```go
func longestIdealString(s string, k int) int {
    n := len(s)
    dp := make([][]int, 26)
    for i := range dp {
        dp[i] = make([]int, k+1)
    }
    
    maxLen := 0
    for i := 0; i < n; i++ {
        for j := 0; j < 26; j++ {
            for l := 0; l <= k; l++ {
                if int(s[i]-'a') == j {
                    // base case: the current letter is the same as the one we are considering
                    dp[j][l] = max(dp[j][l], l+1)
                } else {
                    // base case: the current letter is different from the one we are considering
                    dp[j][l] = max(dp[j][l], dp[int(s[i]-'a')][l]+1)
                }
            }
            maxLen = max(maxLen, dp[j][k])
        }
    }
    
    return maxLen
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

The time complexity of this solution is O(n * k), where n is the length of the string s.