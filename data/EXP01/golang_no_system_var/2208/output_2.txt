Here is the implementation in Go:

```go
func halveArray(nums []int) int {
    sum := 0
    for _, num := range nums {
        sum += num
    }

    target := sum / 2
    maxNum := max(nums)

    for target > 0 {
        if maxNum%2 == 1 {
            target -= maxNum / 2
            maxNum /= 2
        } else {
            diff := target - maxNum/2
            if diff >= 0 {
                target -= maxNum / 2
                maxNum /= 2
            } else {
                maxNum /= 2
            }
        }
    }

    operations := 0
    for _, num := range nums {
        operations += countOperations(num)
    }

    return operations
}

func max(nums []int) int {
    maxNum := nums[0]
    for i := 1; i < len(nums); i++ {
        if nums[i] > maxNum {
            maxNum = nums[i]
        }
    }
    return maxNum
}

func countOperations(num int) int {
    operations := 0
    for num > 0 && num%2 == 0 {
        num /= 2
        operations++
    }
    return operations
}
```

In this implementation, the `halveArray` function takes an array `nums` as input and returns the minimum number of operations to reduce the sum of `nums` by at least half.

The function first calculates the sum of all the numbers in the array. Then, it initializes the `target` variable as half of the sum. The `maxNum` variable is used to keep track of the maximum number in the array.

The function then enters a loop that continues until the `target` is reduced to zero. Inside the loop, it checks if the `maxNum` is odd. If it is, it reduces `target` by half of `maxNum` and updates `maxNum` as well. If `maxNum` is even, it calculates the difference between `target` and half of `maxNum`. If the difference is greater than or equal to zero, it reduces `target` by half of `maxNum` and updates `maxNum`. Otherwise, it just updates `maxNum` without reducing `target`.

After reducing `target` to zero, the function initializes the `operations` variable to zero. It then iterates over each number in the array and calls the `countOperations` function to count the number of operations required to reduce that number to zero. The result is accumulated in the `operations` variable.

Finally, the function returns the `operations` variable as the minimum number of operations to reduce the sum of `nums` by at least half.