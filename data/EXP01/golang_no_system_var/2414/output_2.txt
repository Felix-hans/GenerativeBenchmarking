Here's one way to implement the `longestContinuousSubstring` function in Go:

```go
func longestContinuousSubstring(s string) int {
    maxLen := 0
    currLen := 1

    for i := 1; i < len(s); i++ {
        if s[i] > s[i-1] {
            currLen++
        } else {
            currLen = 1
        }
        if currLen > maxLen {
            maxLen = currLen
        }
    }

    return maxLen
}
```

Here's an explanation of how the function works:
1. Initialize `maxLen` and `currLen` variables to keep track of the maximum length and current length of the alphabetical continuous substring, respectively.
2. Iterate over the characters of the input string, starting from the second character (`i := 1`).
3. If the current character is greater than the previous character in the alphabet (`s[i] > s[i-1]`), increment `currLen` by 1, indicating that the substring is still alphabetical.
4. If the current character is not greater than the previous character, reset `currLen` to 1, indicating that a new substring should start.
5. If the current `currLen` is greater than the current `maxLen`, update `maxLen` to be equal to `currLen`.
6. After the loop ends, return the `maxLen` as the result.

This solution has a time complexity of O(n), where n is the length of the input string.