To solve this problem, we can use a greedy approach. First, we sort the players and trainers arrays in non-decreasing order. Then, we iterate through the players array and for each player, we try to find the trainer with the minimum training capacity that can match with the player. If such a trainer is found, we increment the count of matchings and remove the trainer from the array of trainers. Finally, we return the count of matchings.

Here is the implementation in Go:

```go
import "sort"

func matchPlayersAndTrainers(players []int, trainers []int) int {
    // Sort players and trainers in non-decreasing order
    sort.Ints(players)
    sort.Ints(trainers)

    // Count of matchings
    count := 0

    // Iterate through players
    for _, player := range players {
        // Search for the trainer with the minimum training capacity that can match with the player
        found := false
        for i, trainer := range trainers {
            if player <= trainer {
                // Player can be matched with this trainer
                found = true
                count++
                // Remove the trainer from the array of trainers
                trainers = append(trainers[:i], trainers[i+1:]...)
                break
            }
        }
        if !found {
            // No trainer found for this player
            break
        }
    }

    return count
}
```

The time complexity of this solution is O(n log n), where n is the length of the players array or the trainers array, whichever is smaller. This is because we sort the players and trainers arrays, which takes O(n log n) time, and then we iterate through the players array once, which takes O(n) time.