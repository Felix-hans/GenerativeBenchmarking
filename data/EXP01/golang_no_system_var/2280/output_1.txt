To solve this task, we can iterate through the stockPrices array and check if the current point lies on the same line as the previous point. If not, we count it as a new line.

Here's the implementation:

```go
func minimumLines(stockPrices [][]int) int {
    n := len(stockPrices)
    if n == 0 {
        return 0
    }
    
    lines := 1
    prevSlope := float64(stockPrices[1][1] - stockPrices[0][1]) / float64(stockPrices[1][0] - stockPrices[0][0])
    
    for i := 2; i < n; i++ {
        slope := float64(stockPrices[i][1] - stockPrices[i-1][1]) / float64(stockPrices[i][0] - stockPrices[i-1][0])
        
        if slope != prevSlope {
            lines++
            prevSlope = slope
        }
    }
    
    return lines
}
```

The main idea is to calculate the slope between two adjacent points and compare it with the previous slope. If they are different, we increment the lines count.

In the above code, we first handle the special case when the stockPrices array is empty. Then, we set the initial value of lines to 1 and calculate the slope between the first two points. 

After that, we iterate from the third point to the last point and calculate the slope between the current point and the previous point. If the slope is different from the previous slope, we increment the lines count and update the previous slope.

Finally, we return the lines count as the minimum number of lines needed to represent the line chart.

The time complexity of this solution is O(n), where n is the length of the stockPrices array, since we iterate through the array once. The space complexity is O(1), since we only use a constant amount of extra space.