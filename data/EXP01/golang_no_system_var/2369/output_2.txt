Here is the implementation of the given task in Go:

```go
func validPartition(nums []int) bool {
    n := len(nums)
    if n < 3 {
        return false
    }

    isValid := func(arr []int) bool {
        m := len(arr)
        if m == 2 && arr[0] == arr[1] {
            return true
        } else if m == 3 && (arr[0] == arr[1] && arr[1] == arr[2] || arr[0]+1 == arr[1] && arr[1]+1 == arr[2]) {
            return true
        }
        return false
    }

    start := 0
    for start < n-1 {
        end := start + 2
        curr := []int{}
        for end < n && !isValid(curr) {
            curr = nums[start : end+1]
            end++
        }
        if isValid(curr) {
            return true
        }
        start++
    }

    return false
}
```

Explanation:
1. We check if the length of the array `nums` is less than 3, in which case there can be no valid partition, so we return `false` immediately.
2. We define a helper function `isValid` which checks if a given subarray satisfies one of the valid partition conditions.
3. We iterate through the array using a `start` pointer. We try to form subarrays of length 2 or 3 consecutively starting from `start`.
4. For each subarray, we check if it is a valid partition using the `isValid` function. If yes, we return `true`.
5. If we have exhausted all possible subarrays without finding a valid partition, we return `false` at the end.