Here is the implementation of the given task in Python:

```python
class Solution:
    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:
        def is_edit_distance_one(s: str, t: str) -> bool:
            if len(s) != len(t):
                return False
            count_diff = 0
            for i in range(len(s)):
                if s[i] != t[i]:
                    count_diff += 1
                    if count_diff > 1:
                        return False
            return count_diff == 1
        
        def is_edit_distance_two(s: str, t: str) -> bool:
            if len(s) != len(t):
                return False
            count_diff = 0
            for i in range(len(s)):
                if s[i] != t[i]:
                    count_diff += 1
                    if count_diff > 2:
                        return False
            return count_diff == 2
        
        result = []
        for query in queries:
            for word in dictionary:
                if query == word or is_edit_distance_one(query, word) or is_edit_distance_two(query, word):
                    result.append(query)
                    break
        return result
```

We define two helper functions `is_edit_distance_one` and `is_edit_distance_two` to check if two strings have an edit distance of one or two, respectively.

Then, we iterate over each query in `queries` and compare it with each word in `dictionary`. If the query is equal to the word or has an edit distance of one or two with the word, we add it to the `result` list.

Finally, we return the `result` list containing all the words from queries that match with some word from the dictionary after a maximum of two edits.