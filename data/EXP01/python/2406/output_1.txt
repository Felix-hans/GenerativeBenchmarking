To solve the problem, we can use the greedy algorithm approach. We will sort the intervals based on their starting point and then iterate through each interval. For each interval, we check if it overlaps with the previous interval in the group. If it does not overlap, we start a new group. If it overlaps, we add it to the current group. At the end, the total number of groups formed will be the minimum number of groups needed.

Here is the implementation of the `minGroups` function:

```python
from typing import List

class Solution:
    def minGroups(self, intervals: List[List[int]]) -> int:
        intervals.sort(key=lambda x: x[0])  # Sort intervals based on starting point
        groups = 1  # Initialize the number of groups

        end = intervals[0][1]  # Initialize the end point of the first interval
        for i in range(1, len(intervals)):
            if intervals[i][0] > end:  # If the interval does not overlap with the previous one
                groups += 1  # Start a new group
                end = intervals[i][1]  # Update the end point
            else:
                end = max(end, intervals[i][1])  # Update the end point if the interval overlaps
        
        return groups
```

We can test the function with the given examples:

```python
intervals1 = [[5,10],[6,8],[1,5],[2,3],[1,10]]
intervals2 = [[1,3],[5,6],[8,10],[11,13]]

solution = Solution()
print(solution.minGroups(intervals1))  # Output: 3
print(solution.minGroups(intervals2))  # Output: 1
```

The output will be:

```
3
1
```