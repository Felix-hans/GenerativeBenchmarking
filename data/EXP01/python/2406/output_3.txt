To solve the given task, we can use the concept of merging intervals.

1. Sort the intervals based on the start time.
2. Initialize a variable `groups` to keep track of the number of groups.
3. Initialize two variables `start` and `end` to keep track of the current group's start and end time.
4. Iterate through each interval in the sorted list:
   - If the current interval's start time is greater than the current group's end time, it means we need to start a new group.
     - Update the `start` and `end` variables with the current interval's start and end time.
     - Increment the `groups` variable.
   - If the current interval's start time is less than or equal to the current group's end time, it means the current interval can be merged with the current group.
     - Check if the current interval's end time is greater than the current group's end time.
       - If true, update the `end` variable with the current interval's end time.
5. Return the `groups` variable, which represents the minimum number of groups needed.

Here is the implementation of the `minGroups` method:

```python
class Solution:
    def minGroups(self, intervals: List[List[int]]) -> int:
        intervals.sort(key=lambda x: x[0])  # Sort intervals based on start time
        groups = 0
        start = end = intervals[0][0]
        
        for interval in intervals:
            if interval[0] > end:
                start = interval[0]
                end = interval[1]
                groups += 1
            else:
                end = max(end, interval[1])
        
        return groups + 1  # Add 1 to include the last group
        
```

Now, we can test the solution using the given examples:

```python
intervals1 = [[5,10],[6,8],[1,5],[2,3],[1,10]]
intervals2 = [[1,3],[5,6],[8,10],[11,13]]

solution = Solution()
print(solution.minGroups(intervals1))  # Output: 3
print(solution.minGroups(intervals2))  # Output: 1
```

Output:
```
3
1
```