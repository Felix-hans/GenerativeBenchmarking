To solve this task, we can use a sliding window approach. We will maintain two pointers, left and right, to represent the current window. We will initialize both pointers at the start of the array.

We will iterate through the array using the right pointer. For each element, we will check if it is zero. If it is zero, we will increment a count variable by 1.

Next, we will check if the size of the window (right - left + 1) is greater than the count variable. If it is, it means that there are zeros in the subarray, so we will increment the count variable by the size of the window minus the count variable.

Finally, we will move the left pointer to the right by 1 position and repeat the process.

Let's implement this solution:


```python
from typing import List

class Solution:
    def zeroFilledSubarray(self, nums: List[int]) -> int:
        count = 0
        left = 0
        zeros = 0
        
        for right in range(len(nums)):
            if nums[right] == 0:
                zeros += 1
                
            if right - left + 1 > zeros:
                count += right - left + 1 - zeros
                
            while zeros > 0:
                if nums[left] == 0:
                    zeros -= 1
                left += 1
                    
        return count
```

Let's test the solution with the provided examples:


```python
solution = Solution()

nums = [1,3,0,0,2,0,0,4]
print(solution.zeroFilledSubarray(nums))  # Output: 6

nums = [0,0,0,2,0,0]
print(solution.zeroFilledSubarray(nums))  # Output: 9

nums = [2,10,2019]
print(solution.zeroFilledSubarray(nums))  # Output: 0
```