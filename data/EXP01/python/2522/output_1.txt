To solve the problem, we can use a greedy approach. We iterate through the string from left to right, keeping track of the current substring and its value. If the value of the current substring exceeds k, we cannot include it in a good partition and we start a new substring. If the value of the current substring is less than or equal to k, we continue adding characters to it. 

Here is the implementation of the Solution class:

```
class Solution:
    def minimumPartition(self, s: str, k: int) -> int:
        n = len(s)
        
        # Initialize variables
        substr = ""
        value = 0
        count = 0
        
        for i in range(n):
            digit = int(s[i])
            
            # If adding the current digit would exceed k, start a new substring
            if value + digit > k:
                substr = ""
                value = 0
                count += 1
            
            # Add the current digit to the current substring and update its value
            substr += s[i]
            value += digit
        
        # If there is a non-empty substring at the end, increment the count
        if substr:
            count += 1
        
        # If there are no good partitions, return -1
        if count == 0:
            return -1
        
        return count
```

We can test the solution using the provided examples:

```
# Example 1
s = "165462"
k = 60
solution = Solution()
print(solution.minimumPartition(s, k))  # Output: 4

# Example 2
s = "238182"
k = 5
solution = Solution()
print(solution.minimumPartition(s, k))  # Output: -1
```

The output is correct for both examples.