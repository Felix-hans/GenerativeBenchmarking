To solve this problem, we can use dynamic programming. We will define a 1D array dp where dp[i] represents the minimum number of substrings required to partition the string s[0:i] such that each substring has a value less than or equal to k.

For every index i in the range 0 to len(s)-1, we will check all possible substrings formed from s[0:i+1] and find the one with the maximum value less than or equal to k. We will update dp[i] with the minimum value found.

To find the maximum value less than or equal to k for a substring s[i:j], we can iterate from j-1 to i and calculate the value of the substring as int(s[i:j]) and check if it is less than or equal to k. If it is, we update the maximum value found.

Finally, we return dp[len(s)-1] as the result.

Here is the implementation of the above approach:

```
class Solution:
    def minimumPartition(self, s: str, k: int) -> int:
        n = len(s)
        dp = [float('inf')] * n
        dp[0] = 1
        for i in range(1, n):
            for j in range(i, -1, -1):
                if int(s[j:i+1]) <= k:
                    dp[i] = min(dp[i], dp[j-1] + 1)
        return dp[n-1] if dp[n-1] != float('inf') else -1
```

The time complexity of this solution is O(n^2) and the space complexity is O(n).