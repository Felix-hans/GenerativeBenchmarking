To solve this problem, we can sort both the players and trainers arrays in ascending order. Then, we can iterate through both arrays simultaneously and check if the player's ability is less than or equal to the trainer's training capacity. If it is, we can increment the count of matchings and move to the next player and trainer. If it isn't, we move to the next trainer.

Here is the implementation of the `matchPlayersAndTrainers` function:

```
class Solution:
    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:
        players.sort()
        trainers.sort()
        
        count = 0
        player_idx = 0
        trainer_idx = 0
        
        while player_idx < len(players) and trainer_idx < len(trainers):
            if players[player_idx] <= trainers[trainer_idx]:
                count += 1
                player_idx += 1
                trainer_idx += 1
            else:
                trainer_idx += 1
        
        return count
```

Time complexity analysis:
- Sorting the players and trainers arrays takes O(n log n) time, where n is the length of the arrays.
- The while loop iterates through both arrays once, which takes O(n) time.
Therefore, the overall time complexity of the function is O(n log n).

Space complexity analysis:
- The function uses constant extra space, so the space complexity is O(1).